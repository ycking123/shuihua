# 会议时间排序优化计划

## 问题分析

当前实现存在以下问题：
1. **只有会议开始时间**：数据库只使用了 `start_time`，没有同时展示"发送链接时间"（`created_at`）
2. **排序逻辑不完整**：用户希望可以按两种时间排序，并且标题显示的时间要和排序方式对应

## 需求

1. **记录两个时间**：
   - `start_time`：会议真实开始时间（从腾讯会议 API 获取）
   - `created_at`：发送链接时间（会议记录创建时间）

2. **动态排序和显示**：
   - 选择"会议时间"排序 → 按会议开始时间排序，标题显示会议开始时间
   - 选择"发送时间"排序 → 按发送链接时间排序，标题显示发送链接时间

3. **适用范围**：
   - 会议纪要列表
   - 待办事项列表（会议关联的待办）

---

## 修改计划

### 1. 后端修改

#### 1.1 修改 MeetingResponse 模型 (`server/routers/meetings.py`)

```python
class MeetingResponse(BaseModel):
    id: str
    title: str
    start_time: datetime          # 会议开始时间
    created_at: datetime          # 发送链接时间（新增）
    end_time: datetime
    location: Optional[str] = None
    summary: Optional[str] = None
    transcript: Optional[str] = None
    organizer_id: Optional[str] = None
    todos_count: int = 0
```

#### 1.2 修改会议列表 API 支持排序 (`server/routers/meetings.py`)

```python
@router.get("/", response_model=List[MeetingResponse])
def get_meetings(
    skip: int = 0, 
    limit: int = 100, 
    sort_by: str = "start_time",  # "start_time" | "created_at"
    db: Session = Depends(get_db)
):
    if sort_by == "created_at":
        query = db.query(Meeting).order_by(Meeting.created_at.desc())
    else:
        query = db.query(Meeting).order_by(Meeting.start_time.desc())
    
    meetings = query.offset(skip).limit(limit).all()
    return [db_meeting_to_response(m, db) for m in meetings]
```

#### 1.3 修改 TodoItemSchema (`server/routers/todos.py`)

```python
class TodoItemSchema(BaseModel):
    # ... 现有字段 ...
    meeting_start_time: Optional[str] = None   # 会议开始时间（重命名）
    meeting_created_at: Optional[str] = None   # 发送链接时间（新增）
```

#### 1.4 修改待办列表 API (`server/routers/todos.py`)

```python
@router.get("/api/todos", response_model=List[TodoItemSchema])
def get_todos(
    http_request: Request, 
    db: Session = Depends(get_db), 
    sort_by: str = "created_at"  # "created_at"(发送时间) | "meeting_start_time"(会议时间)
):
    # 排序逻辑修改
    if sort_by == "meeting_start_time":
        query = query.order_by(
            Meeting.start_time.is_(None),
            desc(Meeting.start_time),
            desc(Todo.created_at)
        )
    else:  # sort_by == "created_at" (发送链接时间)
        query = query.order_by(
            Meeting.created_at.is_(None),
            desc(Meeting.created_at),
            desc(Todo.created_at)
        )
```

### 2. 前端修改

#### 2.1 修改排序选项 (`components/TodoView.tsx`)

```tsx
type SortByType = 'created_at' | 'meeting_start_time';

// 排序按钮
<button onClick={() => setSortBy('created_at')}>
  <Clock size={10} /> 发送时间
</button>
<button onClick={() => setSortBy('meeting_start_time')}>
  <Calendar size={10} /> 会议时间
</button>
```

#### 2.2 修改待办列表显示逻辑 (`components/TodoView.tsx`)

```tsx
// 待办卡片时间显示
{sortBy === 'meeting_start_time' && item.meeting_start_time 
  ? <><Calendar size={10} />{item.meeting_start_time}</>
  : <><Clock size={10} />{item.meeting_created_at || item.time}</>
}
```

#### 2.3 修改会议纪要列表 (`components/TodoView.tsx`)

```tsx
// 会议纪要卡片 - 需要传递 sortBy 参数并获取排序后的数据
{meetingMinutes.map((item) => (
  <div>
    <span>
      {sortBy === 'meeting_start_time'
        ? <><Calendar size={10} />{formatTime(item.start_time)}</>
        : <><Clock size={10} />{formatTime(item.created_at)}</>
      }
    </span>
    <h3>{item.title}</h3>
  </div>
))}
```

#### 2.4 修改 API 请求 (`components/TodoView.tsx`)

```tsx
// 获取待办时传递排序参数
const resTodos = await fetch(`${baseUrl}/todos?sort_by=${sortBy}`, { headers });

// 获取会议时也需要传递排序参数
const resMeetings = await fetch(`${baseUrl}/meetings?sort_by=${sortBy}`, { headers });
```

---

## 文件修改清单

| 文件 | 修改内容 |
|------|----------|
| `server/routers/meetings.py` | 添加 `created_at` 字段，支持 `sort_by` 参数 |
| `server/routers/todos.py` | 重命名 `meeting_time` → `meeting_start_time`，新增 `meeting_created_at` |
| `components/TodoView.tsx` | 修改排序类型、时间显示逻辑、API 请求参数 |

---

## 测试验证

1. 创建测试脚本验证两种排序方式
2. 验证会议纪要列表正确显示两种时间
3. 验证待办列表正确显示两种时间
4. 验证排序结果符合预期

---

## 数据库说明

**无需修改数据库结构**：
- `Meeting.start_time` 已存在，存储会议真实开始时间
- `Meeting.created_at` 已存在，存储发送链接时间
